---
title: "Colombia - reporting biases in death data"
author: "Oliver Ratmann"
#output: pdf_document 
output: 
  bookdown::html_document2:
    toc: TRUE
    toc_float: TRUE
    highlight: tango
  bookdown::pdf_book:
    keep_tex: yes
---

<style type="text/css">
h1{
  font-size: 24pt;
}
h2{
  font-size: 18pt;
}
body{
  font-size: 12pt;
}
</style>

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  cache.lazy = FALSE,
  comment = "#>"
)
```

# Packages

```{r, include=TRUE, eval=TRUE, message=FALSE, echo=TRUE, warning=FALSE, tidy=TRUE}
require(data.table) # data mangling
require(ggplot2) #for general plotting
require(ggsci) #for color palettes used by scientific journals
require(rcartocolor)
require(sf)
require(spatstat)
require(raster)
require(spdep)
require(patchwork)
require(knitr)
require(kableExtra)
require(tidyverse)
require(fitdistrplus)
require(mgcv)

home.dir <- '/Users/or105/Library/CloudStorage/OneDrive-ImperialCollegeLondon/OR_Work/OCAY_Program'
#home.dir <- '/Users/avramaral/Library/CloudStorage/OneDrive-SharedLibraries-ImperialCollegeLondon/Ratmann, Oliver - OCAY_Program/'
data.dir <- file.path(home.dir, 'Colombia_primary_data')
out.dir <- file.path(home.dir, 'Colombia_analysis_reporting_bias_in_deaths')
stamp <- gsub('-','',Sys.Date())
```

# Read data
```{r, include=TRUE, eval=TRUE, message=FALSE, echo=TRUE, warning=FALSE, tidy=TRUE}
dgeo <- as.data.table(read.csv(file.path(data.dir,'Files_Colombia/geo_info.csv')))
#dmap <- readRDS(file.path(data.dir,'Files_Colombia','colombia_map_municipality.RDS'))
dmap <- readRDS(file.path(data.dir,'summarised_data','official_colombia_map_municipality.RDS'))
names(dmap)[1] <- 'mun' 
dmap$mun <- as.integer(as.character(dmap$mun))

# add capitals to Departments
dgeo[, capital := mun == dep*1e3 + 1] # Check "Cundinamarca" (capital is also "Bogotá")
# subset(dgeo, capital)
# TODO 25001 Cundinamarca  Agua De Dios is this correct?

# Departmental GBP data from https://www.dane.gov.co/index.php/en/statistics-by-topic-1/national-accounts/departmental-national-accounts
dgbp <- read.csv(file.path(data.dir,'Files_Colombia/anexo-2019-preliminar-PIB-total-por-departamento.csv'),
                 skip = 8, 
                 nrow = 34,
                 header = TRUE)
dgbp <- as.data.table(dgbp)
setnames(dgbp, 1:2, c('dep','dep_name'))
set(dgbp, NULL, c('X','dep_name'), NULL)
dgbp <- melt(dgbp, id.vars = c('dep'), value.name = 'gdp_per_capita', variable.name = 'year')
dgbp <- subset(dgbp, !is.na(dep))
set(dgbp, NULL, 'gdp_per_capita', dgbp[, as.integer(gsub(',','',gdp_per_capita))])
set(dgbp, NULL, 'year', dgbp[, as.integer(gsub('X|pr|p','',year))])
saveRDS(dplyr::as_tibble(dplyr::arrange(dgbp, dep)), paste(data.dir, "/summarised_data/gbp.RDS", sep = ""))

# Municipal GBP data from https://www.dane.gov.co/files/investigaciones/pib/departamentales/B_2015/anexo-2018-provisional-valor-agregado-municipio-2011-2018.xlsx
# in units of 1000 million pesos
dgbpm <- read.csv(file.path(data.dir,'Files_Colombia','anexo-2018-provisional-valor-agregado-municipio-2011-2018_sheet9.csv'),
                 nrow = 1122,
                 header = TRUE)
dgbpm <- as.data.table(dgbpm)
setnames(dgbpm, 1:4, c('mun','mun_name','dep','dep_name'))
setnames(dgbpm, 'X.Valor.agregado..', 'va')
set(dgbpm, NULL, c(5L:7L,9L), NULL)
set(dgbpm, NULL, 'va', dgbpm[, 1e3*as.integer(gsub(',','',va))])

# Population sizes from DANE
dpop <- as.data.table(readRDS(file.path(data.dir,'Population_DANE','pop_all.RDS')))
dpop_cut_age <- as.data.table(readRDS(file.path(data.dir,'Population_DANE','pop_gender.RDS')))
set(dpop, NULL, 'mun', dpop[, as.integer(as.character(mun))])
set(dpop_cut_age, NULL, 'mun', dpop_cut_age[, as.integer(as.character(mun))])
setnames(dpop, 'population','pop_DANE')
setnames(dpop_cut_age, 'population','pop_DANE')

tmp <- readRDS(file.path(data.dir,'Files_Colombia','EQUALIZED_RATES.RDS'))
dm <- as.data.table(tmp$mortality_rates)
db <- as.data.table(tmp$fertility_rates)

setnames(dm, 'loc','mun')
setnames(db, 'loc','mun')
set(dm, NULL, 'mun', dm[, as.integer(as.character(mun))])
set(db, NULL, 'mun', db[, as.integer(as.character(mun))])
set(dm, NULL, 'death_rate', NULL)
set(db, NULL, 'fertility_rate', NULL)
setnames(dm, 'population','pop_PREPR')
setnames(db, 'population','pop_PREPR')

# make sure we have all counts on the cartesian product of variables
tmp <- expand.grid(mun = dpop_cut_age[gender == 'Male', unique(mun)],
                   gender = 'Male', 
                   age = dpop_cut_age[gender == 'Male', unique(age)],
                   year = dpop_cut_age[gender == 'Male', unique(year)]
                   )
tmp <- as.data.table(tmp)
tmp2 <- expand.grid(mun = dpop_cut_age[gender == 'Female', unique(mun)],
                    gender = 'Female', 
                    age = dpop_cut_age[gender == 'Female', unique(age)],
                    year = dpop_cut_age[gender == 'Female', unique(year)]
                    )
tmp2 <- as.data.table(tmp2)
tmp <- rbind(tmp, tmp2)

dpop_cut_age <- merge(tmp, dpop_cut_age, by = c('mun','gender','age','year'), all.x = TRUE)
cat('\ndpop_cut_age: number of missing pop sizes, n=',nrow(subset(dpop_cut_age, is.na(pop_DANE))))

dpop <- merge(tmp, dpop, by = c('mun','gender','age','year'), all.x = TRUE)
cat('\ndpop: number of missing pop sizes, n=',nrow(subset(dpop, is.na(pop_DANE))))
# TODO Andre I figure out what s going on in "dpop_cut_age" -- different age strata in men/women
# qhat s the fix for dpop?


# hack for now: # This just ignores elderly. Instead, use the object based on `pop_gender`; i.e., `dpop_cut_age`
set(dpop, dpop[, which(is.na(pop_DANE))],'pop_DANE',0) 

dm <- merge(tmp, dm, by = c('mun','gender','age','year'), all.x = TRUE)
set(dm, dm[, which(is.na(deaths))], 'deaths', 0)

db <- merge(tmp, db, by = c('mun','gender','age','year'), all.x = TRUE)
set(db, db[, which(is.na(births))], 'births', 0)

# TODO Andre presumably zero here means no recorded births/deaths. 
# can you make the cartesian earlier in your code so this goes through all preprocessing too?

```

# Area data at municipality level
```{r, include=TRUE, eval=TRUE, message=FALSE, echo=TRUE, warning=FALSE, tidy=TRUE}
# area from IGAC
# https://www.esri.com/en-us/lg/industry/government/stories/igac-case-study
# https://data.humdata.org/dataset/municipal-population-density/resource/f461a4bd-349e-4666-88b1-c6daf078f980
tmp <- as.data.table(read.csv(file.path(data.dir,'Files_Colombia','densidad-municipios-de-colombia.csv')))
tmp <- subset(tmp, !is.na(COD), select = -c(POB2010, DENSIDAD))
setnames(tmp, c('COD','NAME','AREAKM2'),c('mun','mun_name_check','area'))
set(tmp, NULL, 'area', tmp[, as.integer(gsub(',','',area))])
cat("\nmunicipalities with no data on area: ", tmp[is.na(area),mun])
dgeo <- merge(dgeo, tmp, by = 'mun', all.x = TRUE)
cat("\nmunicipalities with no data on area in dgeo: ", dgeo[is.na(area),mun])

tmp <- data.table(
  mun = as.integer(as.character(dmap$mun)),
  area_2 = as.double(units::set_units(st_area(dmap$geometry), km^2))
)
dgeo <- merge(dgeo, tmp, by = 'mun')

tmp <- subset(dgeo, abs(log(area/area_2)) > log(1.2))
cat("\nThere are municipalities where km2 calculated from the shape file differs from IGAC resources by more than 20%, n=", nrow(tmp))
write.csv(tmp, file = file.path(out.dir, paste0('comparison_of_municipality_area_IGAC_vs_shapefile_',stamp,'.csv')))
```

# Demographics in census year 2018

Switch between population sizes:

```{r, include=TRUE, eval=TRUE, message=FALSE, echo=TRUE, warning=FALSE, tidy=TRUE}
# switch pop sizes
dm <- merge(dm, dpop_cut_age, by = c('mun','gender','age','year'))
db <- merge(db, dpop_cut_age, by = c('mun','gender','age','year'))
setnames(dm, 'pop_DANE', 'pop')
setnames(db, 'pop_DANE', 'pop')

# The population count (check counts) includes all elderly individuals, whereas the birth and death count do not
```

Population density, proportion of men, proportion of people aged <30 years:

```{r, include=TRUE, eval=TRUE, message=FALSE, echo=TRUE, warning=FALSE, tidy=TRUE}
# calculate standardized mortality rates
da <- dm[year == 2018,
         list(pop_t = sum(pop)),
         by = c('mun','year')]

# add geo info
da <- merge(da, dgeo, by = 'mun', all.x = TRUE)
if (any(da[is.na(mun_name),mun]))
{
  cat("\nfound municipalities in death data that are not in geo : ", da[is.na(mun_name),mun])
}
da <- subset(da, !is.na(mun_name))

# calculate population densities
da[, pop_r := pop_t / area_2]
da[, pop_r_disc := cut(
  pop_r, breaks = c(0, 5, 25, 50, 100, 250, 100e3), 
  labels = c('0-4','5-24','25-49','50-99','100-249','250+'), 
  right = FALSE)
  ]

# plot population density
tmp <- data.table(mun = dmap$mun)
tmp[, id := 1:nrow(tmp)]
tmp <- merge(tmp, subset(da, select = c(mun, pop_r_disc)))
setkey(tmp, id)
tmp2 <- copy(dmap)
tmp2[['value']] <- tmp$pop_r_disc
p <- ggplot() +
    geom_sf(data = tmp2, 
            aes(geometry = geometry, 
                fill = value
                ), 
            color = "black") +
    scale_fill_carto_d(name = "Population per km2", palette = "Burg", direction = 1) +
    theme_bw() +
    theme(legend.position = "right",
          text = element_text(size = 14),
          plot.title = element_text(size = 16),
          legend.title = element_text(size = 11),
          panel.grid.major = element_blank(),
          panel.grid.minor = element_blank(),
          panel.border = element_blank(),
          panel.background = element_blank(),
          axis.title = element_blank(),
          axis.text = element_blank(),
          axis.ticks = element_blank()) +
    guides(fill = guide_legend(order = 1))
ggsave(p, file = file.path(out.dir, paste0('Colombia_pop_density_2018_',stamp,'.pdf')), w = 10, h = 10)


# calculate proportion of female population in selected ages 10-59 (women), 10-69 (men)
tmp <- dm[year == 2018 & gender == 'Female',
         list(pop_female_n = sum(pop)),
         by = c('mun','year')]
da <- merge(da, tmp, by = c('mun','year'))
da[, pop_female_p := pop_female_n/pop_t]

# plot population density
tmp <- data.table(mun = dmap$mun)
tmp[, id := 1:nrow(tmp)]
tmp <- merge(tmp, subset(da, select = c(mun, pop_female_p)))
tmp[, pop_female_p_disc := cut(pop_female_p, breaks = c(0,0.4,1.0))]
setkey(tmp, id)
tmp2 <- copy(dmap)
tmp2[['value']] <- tmp$pop_female_p_disc
p <- ggplot() +
    geom_sf(data = tmp2, 
            aes(geometry = geometry, 
                fill = value
                ), 
            color = "black") +
    scale_fill_carto_d(name = "Proportion of women in population (%)", palette = "Teal", direction = -1) +
    theme_bw() +
    theme(legend.position = "right",
          text = element_text(size = 14),
          plot.title = element_text(size = 16),
          legend.title = element_text(size = 11),
          panel.grid.major = element_blank(),
          panel.grid.minor = element_blank(),
          panel.border = element_blank(),
          panel.background = element_blank(),
          axis.title = element_blank(),
          axis.text = element_blank(),
          axis.ticks = element_blank()) +
    guides(fill = guide_legend(order = 1))
ggsave(p, file = file.path(out.dir, paste0('Colombia_proportion_women_2018_',stamp,'.pdf')), w = 10, h = 10)

# TODO check municipalities with <40% women!
tmp <- subset(da, pop_female_p < 0.4 | pop_female_p > 0.6)
write.csv(tmp, file = file.path(out.dir, paste0('Colombia_proportion_women_2018_odd_',stamp,'.csv')))

# calculate proportion of population in ages 10-29 in selected age range
tmp <- dm[year == 2018 & age %in% c("10-14","15-19","20-24","25-29"),
         list(pop_10_29_n = sum(pop)),
         by = c('mun','year')]
da <- merge(da, tmp, by = c('mun','year'))
da[, pop_10_29_p := pop_female_n/pop_t]

# plot proportion of population in ages 10-29 in selected age range
tmp <- data.table(mun = dmap$mun)
tmp[, id := 1:nrow(tmp)]
tmp <- merge(tmp, subset(da, select = c(mun, pop_10_29_p)))
tmp[, pop_10_29_p_disc := cut(pop_10_29_p, breaks = c(0,0.4,1.0))]
setkey(tmp, id)
tmp2 <- copy(dmap)
tmp2[['value']] <- tmp$pop_10_29_p_disc
p <- ggplot() +
    geom_sf(data = tmp2, 
            aes(geometry = geometry, 
                fill = value
                ), 
            color = "black") +
    scale_fill_carto_d(name = "Proportion of people aged 10-29 in population (%)", palette = "Peach", direction = -1) +
    theme_bw() +
    theme(legend.position = "right",
          text = element_text(size = 14),
          plot.title = element_text(size = 16),
          legend.title = element_text(size = 11),
          panel.grid.major = element_blank(),
          panel.grid.minor = element_blank(),
          panel.border = element_blank(),
          panel.background = element_blank(),
          axis.title = element_blank(),
          axis.text = element_blank(),
          axis.ticks = element_blank()) +
    guides(fill = guide_legend(order = 1))
ggsave(p, file = file.path(out.dir, paste0('Colombia_proportion_people_10_29_2018_',stamp,'.pdf')), w = 10, h = 10)


tmp <- subset(da, pop_10_29_p < 0.4 | pop_10_29_p > 0.6)
write.csv(tmp, file = file.path(out.dir, paste0('Colombia_proportion_people_10_29_2018_odd_',stamp,'.csv')))
# TODO check municipalities with <40% young people!

```


# Standardized mortality rates in census year 2018

Standardized mortality rates in census year 2018, ignoring women aged >67 and men aged >77:

```{r, include=TRUE, eval=TRUE, message=FALSE, echo=TRUE, warning=FALSE, tidy=TRUE}
# prepare national reference population
dref <- dm[ year == 2018, 
            list(natl_pop_n = sum(pop)),
            by = c('gender','age')]
dref[, natl_pop_t := sum(natl_pop_n)]
dref[, natl_pop_p := natl_pop_n / natl_pop_t]

# calculate age/sex death rates per municipality
da <- subset(dm, year == 2018, select = -c(mod, pop_PREPR))
da[, mun_death_r_2018 := deaths/pop]
tmp <- da[, which(pop == 0.)]
set(da, tmp, 'mun_death_r_2018', 0.)

# merge national reference population weights
da <- merge(da, dref, by = c('gender','age'), all.x = TRUE)

# calculate standardized mortality rates
da <- da[,
         list(pop_n = sum(pop),
              deaths = sum(deaths),
              death_r = sum(deaths)/sum(pop),
              death_r_std = sum(mun_death_r_2018 * natl_pop_n) / natl_pop_t[1] 
              ),
         by = c('mun','year')]

# add geo info
da <- merge(da, dgeo, by = 'mun', all.x = TRUE)
cat("\nfound municipalities in death data that are not in geo : ", da[is.na(mun_name),mun])
da <- subset(da, !is.na(mun_name))

# add GBP info
da <- merge(da, dgbp, by = c('dep','year'), all.x = TRUE)
setnames(da, 'gdp_per_capita', 'dep_gdp_per_capita')
da <- merge(da, subset(dgbpm, select = c(mun, va)), by = c('mun'), all.x = TRUE)

# calculate population densities
da[, pop_r := pop_n / area_2]
da[, pop_r_disc := cut(
  pop_r, breaks = c(0, 5, 25, 50, 100, 250, 100e3), 
  labels = c('0-4','5-24','25-49','50-99','100-249','250+'), 
  right = FALSE)
  ]

# plot population density
tmp <- data.table(mun = dmap$mun)
tmp[, id := 1:nrow(tmp)]
tmp <- merge(tmp, subset(da, select = c(mun, pop_r_disc)))
setkey(tmp, id)
tmp2 <- copy(dmap)
tmp2[['value']] <- tmp$pop_r_disc
p <- ggplot() +
    geom_sf(data = tmp2, 
            aes(geometry = geometry, 
                fill = value
                ), 
            color = "black") +
    scale_fill_carto_d(name = "Population per km2", palette = "Burg", direction = 1) +
    theme_bw() +
    theme(legend.position = "right",
          text = element_text(size = 14),
          plot.title = element_text(size = 16),
          legend.title = element_text(size = 11),
          panel.grid.major = element_blank(),
          panel.grid.minor = element_blank(),
          panel.border = element_blank(),
          panel.background = element_blank(),
          axis.title = element_blank(),
          axis.text = element_blank(),
          axis.ticks = element_blank()) +
    guides(fill = guide_legend(order = 1))
ggsave(p, file = file.path(out.dir, paste0('Colombia_pop_density_2018_',stamp,'.pdf')), w = 10, h = 10)

# plot population density
#ggplot(da, aes(x= death_r, y= death_r_std)) + geom_point()\
#

# plot standardised death rates
da[, death_r_std_disc := cut(
  death_r_std, breaks = c(-1, 1e-7, 1e-3, 2e-3, 3e-3, 4e-3, 1), 
  labels = c('0','<=1 per 1000','<=2 per 1000','<=3 per 1000','<=4 per 1000','>4 per 1000'), 
  right = TRUE)
  ]

tmp <- data.table(mun = dmap$mun)
tmp[, id := 1:nrow(tmp)]
tmp <- merge(tmp, subset(da, select = c(mun, death_r_std_disc)))
setkey(tmp, id)
tmp2 <- copy(dmap)
tmp2[['value']] <- tmp$death_r_std_disc
p <- ggplot() +
    geom_sf(data = tmp2, 
            aes(geometry = geometry, 
                fill = value
                ), 
            color = "black") +
    scale_fill_carto_d(name = "Standardized mortality rate in 2018", palette = "Burg", direction = 1) +
    theme_bw() +
    theme(legend.position = "right",
          text = element_text(size = 14),
          plot.title = element_text(size = 16),
          legend.title = element_text(size = 11),
          panel.grid.major = element_blank(),
          panel.grid.minor = element_blank(),
          panel.border = element_blank(),
          panel.background = element_blank(),
          axis.title = element_blank(),
          axis.text = element_blank(),
          axis.ticks = element_blank()) +
    guides(fill = guide_legend(order = 1))
ggsave(p, file = file.path(out.dir, paste0('Colombia_mortality_rate_2018_',stamp,'.pdf')), w = 10, h = 10)

# are standardized death rates higher in capitals of departments?
tmp <- unique(subset(da, select = c(dep_name, dep_gdp_per_capita)))
setkey(tmp, dep_gdp_per_capita)
tmp[, dep_name_gdp := factor(1:nrow(tmp), levels = 1:nrow(tmp), labels = dep_name) ]
da <- merge(da, tmp, by = c('dep_name', 'dep_gdp_per_capita'))
p <- ggplot(da, aes(x = dep_name_gdp, y = death_r_std)) +
  geom_boxplot() +
  geom_point(data = subset(da, capital == TRUE), col = 'red') +
  coord_flip() + 
  theme_bw() +
  ylab('standardized\nmortality rate') + 
  xlab('Departments ordered by GBP')
ggsave(p, file = file.path(out.dir, paste0('Colombia_mortality_rate_2018_capital_vs_mun_ordered_by_gdp',stamp,'.png')), w = 10, h = 10)

# GDP by Department
p <- ggplot(data = unique(subset(da, select = c(dep_name_gdp, dep_gdp_per_capita)))) +
  geom_col(aes(x = dep_name_gdp, y = dep_gdp_per_capita)) +
  theme_bw() +
  coord_flip() +
  labs(y = "GDP per capita\n(million pesos)", x = 'Department')
ggsave(p, file = file.path(out.dir, paste0('Colombia_Departments_by_gdp',stamp,'.png')), w = 10, h = 10)

# can we try and work out some correction factor?
dg <- subset(da, select = c(dep, dep_name_gdp, dep_gdp_per_capita, mun, capital, death_r_std))
tmp <- subset(dg, capital, select = c(dep, death_r_std))
setnames(tmp, 'death_r_std', 'death_r_std_capital')
dg <- merge(dg, tmp, by = 'dep')
dg <- dg[, 
         list(death_r_std_capital_quantile = mean(as.integer(death_r_std <= death_r_std_capital))), 
         by = c('dep','dep_name_gdp','dep_gdp_per_capita')
         ]
setorder(dg, -dep_gdp_per_capita)
dg <- subset(dg, dep != 11)
dg[, death_r_std_capital_quantile_run := sapply( 1:nrow(dg), function(i){ mean(dg$death_r_std_capital_quantile[1:i]) })]

p <- ggplot(dg) +
  geom_line(aes( x = dep_name_gdp, y = death_r_std_capital_quantile_run, group = 1)) +
  geom_point(aes( x = dep_name_gdp, y = death_r_std_capital_quantile)) +
  scale_y_continuous( labels = scales::percent ) +
  theme_bw() + 
  coord_flip() +
  labs(y = "proportion of standardized death rates\nbelow that in the capital", x = 'Departments (excl Bogota)\nordered by GDP')
ggsave(p, file = file.path(out.dir, paste0('Colombia_Mortality_rate_2018_prop_below_capital_by_gdp',stamp,'.png')), w = 10, h = 10)

# quantile for Putumayo is 66%
subset(dg, dep_name_gdp == 'Putumayo')
```

# Analyze standardised death reates vs GDP by municipality 

```{r, include=TRUE, eval=TRUE, message=FALSE, echo=TRUE, warning=FALSE, tidy=TRUE}
# prepare national reference population
dref <- dm[ year == 2018, 
            list(natl_pop_n = sum(pop)),
            by = c('gender','age')]
dref[, natl_pop_t := sum(natl_pop_n)]
dref[, natl_pop_p := natl_pop_n / natl_pop_t]

# calculate age/sex death rates per municipality
# smooth out deaths over 2017-2019
# 
da <- dm[year > 2016 & year < 2020, 
         list(deaths = mean(deaths)), 
         by = c('mun','gender','age')
         ]
tmp <- subset(dm, year == 2018, select = -c(deaths, mod, pop_PREPR))
da <- merge(da, tmp, by = c('mun','gender','age'))
#da <- subset(dm, year == 2018, select = -c(mod, pop_PREPR))
da[, mun_death_r_2018 := deaths/pop]
tmp <- da[, which(pop == 0.)]
set(da, tmp, 'mun_death_r_2018', 0.)

# merge national reference population weights
da <- merge(da, dref, by = c('gender','age'), all.x = TRUE)

# calculate standardized mortality rates
da <- da[,
         list(pop_n = sum(pop),
              deaths = sum(deaths),
              death_r = sum(deaths)/sum(pop),
              death_r_std = sum(mun_death_r_2018 * natl_pop_n) / natl_pop_t[1] 
              ),
         by = c('mun','year')]

# add geo info
da <- merge(da, dgeo, by = 'mun', all.x = TRUE)
cat("\nfound municipalities in death data that are not in geo : ", da[is.na(mun_name),mun])
da <- subset(da, !is.na(mun_name))

# add GBP info
da <- merge(da, dgbp, by = c('dep','year'), all.x = TRUE)
setnames(da, 'gdp_per_capita', 'dep_gdp_per_capita')
da <- merge(da, subset(dgbpm, select = c(mun, va)), by = c('mun'), all.x = TRUE)
da[, va_per_capita := va / pop_n]

# reset Bogota as capital of Cundinamarca
set(da, da[, which(dep == 11)], 'dep', 25L)
set(da, da[, which(dep == 25)], 'dep_name', 'Cundinamarca\nincl Bogotá')
set(da, da[, which(mun == 25001)], 'capital', FALSE)

# add density info
da[, pop_r := pop_n / area_2]
da[, pop_r_disc := cut(
  pop_r, breaks = c(0, 5, 25, 50, 100, 250, 100e3), 
  labels = c('0-4','5-24','25-49','50-99','100-249','250+'), 
  right = FALSE)
  ]

tmp <- da[, list(sum_mum_va_per_capita = sum(va_per_capita)), by = c('dep_name', 'dep_gdp_per_capita')]
setorder(tmp, -dep_gdp_per_capita)

p <- ggplot(da, aes(x = pop_r_disc)) +
  geom_bar()


p <- ggplot(da, aes(x = va, y = death_r_std, col = factor(capital, levels = c(TRUE,FALSE), labels = c('state capital','other')))) +
  geom_point(data = subset(da, capital == FALSE)) +
  geom_point(data = subset(da, capital == TRUE)) +
  labs(col = '') + 
  scale_x_log10() +
  scale_colour_carto_d(palette = "Vivid", direction = -1) +
  theme_bw() +
  labs(x = 'valore agregado', y = 'mean standardized death rates 2017-2019') +
  facet_wrap(~dep_name, ncol = 6) +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1))
ggsave(p, file = file.path(out.dir, paste0('Colombia_Mortality_rate_2018_by_va_',stamp,'.png')), w = 10, h = 10)


p <- ggplot(da, aes(x = va, y = death_r_std, col = pop_r_disc)) +
  geom_point() +
  labs(col = '') + 
  scale_x_log10() +
  scale_colour_carto_d(palette = "Burg") +
  theme_bw() +
  labs(x = 'valore agregado', y = 'mean standardized death rates 2017-2019', colour = 'Population per km2') +
  facet_wrap(~dep_name, ncol = 6) +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1))
ggsave(p, file = file.path(out.dir, paste0('Colombia_Mortality_rate_2018_by_va2_',stamp,'.png')), w = 10, h = 10)


p <- ggplot(da, aes(x = va, y = death_r_std)) +
  geom_point(aes(col = pop_r_disc, 
                 pch = factor(capital, levels = c(TRUE,FALSE), labels = c('state capital','other')), 
                 size = factor(capital, levels = c(TRUE,FALSE), labels = c('state capital','other'))
                 )) +
  labs(col = '') + 
  scale_x_log10() +
  scale_size_manual(values = c(4,1)) +
  scale_colour_carto_d(palette = "Burg") +
  theme_bw() +
  labs(x = 'valore agregado', y = 'mean standardized death rates 2017-2019', colour = 'Population per km2', size = '', pch = '') +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1)) + 
  geom_smooth(colour = 'black') +
  geom_smooth(data = subset(da, capital), colour = 'black', lty = 'dotted', method = 'lm') 
ggsave(p, file = file.path(out.dir, paste0('Colombia_Mortality_rate_2018_by_va2_overall_',stamp,'.png')), w = 10, h = 10)


p <- ggplot(da, aes(x = pop_r, y = death_r_std, col = factor(capital, levels = c(TRUE,FALSE), labels = c('state capital','other')))) +
  geom_point(data = subset(da, capital == FALSE)) +
  geom_point(data = subset(da, capital == TRUE)) +
  labs(col = '') + 
  scale_x_log10() +
  scale_colour_carto_d(palette = "Vivid", direction = -1) +
  theme_bw() +
  labs(x = 'Population density', y = 'mean standardized death rates 2017-2019') +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1)) +
  geom_smooth(colour = 'black')
ggsave(p, file = file.path(out.dir, paste0('Colombia_Mortality_rate_2018_by_popdensity_overall_',stamp,'.png')), w = 7, h = 7)


p <- ggplot(da, aes(x = va, y = pop_n/area_2, col = factor(capital, levels = c(TRUE,FALSE), labels = c('state capital','other')))) +
  geom_point(data = subset(da, capital == FALSE)) +
  geom_point(data = subset(da, capital == TRUE)) +
  labs(col = '') + 
  scale_x_log10() +
  scale_y_log10() +
  scale_colour_carto_d(palette = "Vivid", direction = -1) +
  theme_bw() +
  labs(x = 'valore agregado', y = 'population density 2018 per km2') +
  facet_wrap(~dep_name, ncol = 6) +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1))
ggsave(p, file = file.path(out.dir, paste0('Colombia_Pop_density_2018_by_va_',stamp,'.png')), w = 10, h = 10)

library(splines)
summary(lm(death_r_std ~ bs(va) + bs(pop_r), data = da))
summary(lm(death_r_std ~ bs(va) + pop_r_disc, data = da))

```

# Under-reporting corrections for standardised death reates with gam

```{r, include=TRUE, eval=TRUE, message=FALSE, echo=TRUE, warning=FALSE, tidy=TRUE}
# prepare national reference population
dref <- dm[ year == 2018, 
            list(natl_pop_n = sum(pop)),
            by = c('gender','age')]
dref[, natl_pop_t := sum(natl_pop_n)]
dref[, natl_pop_p := natl_pop_n / natl_pop_t]

# calculate age/sex death rates per municipality
# smooth out deaths over 2017-2019
# 
da <- dm[year > 2016 & year < 2020, 
         list(deaths = mean(deaths)), 
         by = c('mun','gender','age')
         ]
tmp <- subset(dm, year == 2018, select = -c(deaths, mod, pop_PREPR))
da <- merge(da, tmp, by = c('mun','gender','age'))
#da <- subset(dm, year == 2018, select = -c(mod, pop_PREPR))
da[, mun_death_r_2018 := deaths/pop]
tmp <- da[, which(pop == 0.)]
set(da, tmp, 'mun_death_r_2018', 0.)

# merge national reference population weights
da <- merge(da, dref, by = c('gender','age'), all.x = TRUE)

# calculate standardized mortality rates
da <- da[,
         list(pop_n = sum(pop),
              deaths = sum(deaths),
              death_r = sum(deaths)/sum(pop),
              death_r_std = sum(mun_death_r_2018 * natl_pop_n) / natl_pop_t[1] 
              ),
         by = c('mun','year')]

# add geo info
da <- merge(da, dgeo, by = 'mun', all.x = TRUE)
cat("\nfound municipalities in death data that are not in geo : ", da[is.na(mun_name),mun])
da <- subset(da, !is.na(mun_name))

# add GBP info
da <- merge(da, dgbp, by = c('dep','year'), all.x = TRUE)
setnames(da, 'gdp_per_capita', 'dep_gdp_per_capita')
da <- merge(da, subset(dgbpm, select = c(mun, va)), by = c('mun'), all.x = TRUE)
da[, va_per_capita := va / pop_n]

# reset Bogota as capital of Cundinamarca
set(da, da[, which(dep == 11)], 'dep', 25L)
set(da, da[, which(dep == 25)], 'dep_name', 'Cundinamarca\nincl Bogotá')
set(da, da[, which(mun == 25001)], 'capital', FALSE)

# add density info
da[, pop_r := pop_n / area_2]
da[, pop_r_disc := cut(
  pop_r, breaks = c(0, 5, 25, 50, 100, 250, 100e3), 
  labels = c('0-4','5-24','25-49','50-99','100-249','250+'), 
  right = FALSE)
  ]

# determine best fit distribution to standardised death rates 
das <- subset(da, va > 1e6)
fln <- fitdist(das$death_r_std, "lnorm")
fg <- fitdist(das$death_r_std, "gamma")
fw <- fitdist(das$death_r_std, "weibull")
cdfcomp(list(fln, fg, fw), legendtext = c('lognormal','gamma','weibull'))
gofstat(list(fln, fg, fw), fitnames = c('lognormal','gamma','weibull'))
# both AIC and BIC select Gamma

# read quantiles of best fit
dva6 <- unname(unlist(quantile(fg, prob = c(0.025, 0.5, 0.975))$quantiles))

# determine average trend in standardised death rates by value added with gam
tmp <- subset(da, select = c(mun, va, death_r_std))
set(tmp, NULL, 'va', tmp[, log10(va)])
fgam <- gam( death_r_std ~ s(va, bs = "cs"), data = tmp, method = "REML")
dvaa <- data.table(va = seq(log10(min(da$va)), log10(max(da$va)), by = 0.01))
dvaa[, death_r_std_fitted := unname(unlist(mgcv:::predict.gam(fgam, dvaa, type = 'response', se.fit = FALSE)))]
set(dvaa, NULL, 'va', dvaa[, 10^va])

# determine average trend in standardised death rates by value added with loess
if (0)
{
  tmp <- subset(da, select = c(mun, va, death_r_std))
  set(tmp, NULL, 'va', tmp[, log10(va)])
  floess <- loess( death_r_std ~ va, data = tmp )
  dvaa <- data.table(va = seq(log10(min(da$va)), log10(max(da$va)), by = 0.01))
  dvaa[, death_r_std_fitted := unname(unlist(predict(floess, dvaa, type = 'response', se.fit = FALSE)))]
  set(dvaa, NULL, 'va', dvaa[, 10^va])
}


p <- ggplot(da, aes(x = va, y = death_r_std)) +
  geom_ribbon(aes(ymin = dva6[1], ymax = dva6[3]), fill = 'chocolate4', alpha = 0.2) +
  geom_hline(yintercept = dva6[2], lty = 'dashed', col = 'black', lwd = .8 ) +
  geom_point(aes(col = pop_r_disc, 
                 pch = factor(capital, levels = c(TRUE,FALSE), labels = c('state capital','other')), 
                 size = factor(capital, levels = c(TRUE,FALSE), labels = c('state capital','other'))
                 )) +
  labs(col = '') + 
  scale_x_log10() +
  scale_size_manual(values = c(4,1)) +
  scale_colour_carto_d(palette = "Burg") +
  theme_bw() +
  labs(x = 'valore agregado', y = 'mean standardized death rates 2017-2019', colour = 'Population per km2', size = '', pch = '') +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1)) + 
  geom_line(data = dvaa, aes(x = va, y = death_r_std_fitted), colour = 'black', lwd = .8) 
ggsave(p, file = file.path(out.dir, paste0('Colombia_Mortality_rate_2018_by_va2_overall_gam_',stamp,'.png')), w = 10, h = 10)

# work out adjustment multiplier


dvaa <- subset(da, select = c(mun, va, death_r_std))
set(dvaa, NULL, 'va', dvaa[, log10(va)])
fgam <- gam( death_r_std ~ s(va, bs = "cs"), data = dvaa, method = "REML")
dvaa[, death_r_std_fitted := unname(unlist(mgcv:::predict.gam(fgam, dvaa, type = 'response', se.fit = FALSE)))]
set(dvaa, NULL, 'va', dvaa[, 10^va])

tmp <- dvaa[, 
            list(it = 1:1e3,
                 death_r_std_adjust = rgamma(1e3, fg$estimate[1], fg$estimate[2])), 
            by = c('mun','va')
            ]
dvaa <- merge(dvaa, tmp, by = c('mun','va'))

tmp <- unique(subset(dvaa, select = -c(it, death_r_std_adjust)))
tmp[, death_r_std_adjust := unname(unlist(quantile(fg, prob = c(0.5))$quantiles))]
tmp[, it := 0L]

dvaa <- rbind(tmp, dvaa)

dvaa[, death_r_std_adjust_multiplier := pmax(1.0, death_r_std_adjust / death_r_std_fitted)]

cat('saving adjustment factors to file=',file.path(out.dir, paste0('Colombia_reporting_bias_multiplier_gam_on_std_mortality_rate_vs_va_',stamp,'.rds')))
saveRDS(dvaa, file = file.path(out.dir, paste0('Colombia_reporting_bias_multiplier_gam_on_std_mortality_rate_vs_va_',stamp,'.rds')))

# apply adjustments and plot
da <- merge(da, subset(dvaa, it == 0, select = c(mun, death_r_std_adjust_multiplier)), by = c('mun'))
da[, death_r_std_adj := death_r_std * death_r_std_adjust_multiplier]
da[, death_r_std_adj_disc := cut(
  death_r_std_adj, breaks = c(-1, 1e-7, 1e-3, 2e-3, 3e-3, 4e-3, 1), 
  labels = c('0','<=1 per 1000','<=2 per 1000','<=3 per 1000','<=4 per 1000','>4 per 1000'), 
  right = TRUE)
  ]

tmp <- data.table(mun = dmap$mun)
tmp[, id := 1:nrow(tmp)]
tmp <- merge(tmp, subset(da, select = c(mun, death_r_std_adj_disc)))
setkey(tmp, id)
tmp2 <- copy(dmap)
tmp2[['value']] <- tmp$death_r_std_adj_disc
p <- ggplot() +
    geom_sf(data = tmp2, 
            aes(geometry = geometry, 
                fill = value
                ), 
            color = "black") +
    scale_fill_carto_d(name = "Standardized mortality rate in 2018\nadjusted for under-reporting using the GAM model", palette = "Burg", direction = 1) +
    theme_bw() +
    theme(legend.position = "right",
          text = element_text(size = 14),
          plot.title = element_text(size = 16),
          legend.title = element_text(size = 11),
          panel.grid.major = element_blank(),
          panel.grid.minor = element_blank(),
          panel.border = element_blank(),
          panel.background = element_blank(),
          axis.title = element_blank(),
          axis.text = element_blank(),
          axis.ticks = element_blank()) +
    guides(fill = guide_legend(order = 1))
ggsave(p, file = file.path(out.dir, paste0('Colombia_mortality_rate_2018_adj_gam_on_std_mortality_rate_vs_va_',stamp,'.pdf')), w = 10, h = 10)


p <- ggplot(da, aes(x = va, y = death_r_std_adj)) +
  geom_ribbon(aes(ymin = dva6[1], ymax = dva6[3]), fill = 'chocolate4', alpha = 0.2) +
  #geom_hline(yintercept = dva6[2], lty = 'dashed', col = 'black', lwd = .8 ) +
  geom_point(aes(col = pop_r_disc, 
                 pch = factor(capital, levels = c(TRUE,FALSE), labels = c('state capital','other')), 
                 size = factor(capital, levels = c(TRUE,FALSE), labels = c('state capital','other'))
                 )) +
  labs(col = '') + 
  scale_x_log10() +
  scale_size_manual(values = c(4,1)) +
  scale_colour_carto_d(palette = "Burg") +
  theme_bw() +
  labs(x = 'valore agregado', y = 'adjusted standardized death rates', colour = 'Population per km2', size = '', pch = '') +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1)) + 
  geom_smooth(colour = 'black')
ggsave(p, file = file.path(out.dir, paste0('Colombia_Mortality_rate_2018_adj_gam_on_std_mortality_rate_vs_va_overall_',stamp,'.png')), w = 10, h = 10)
```
