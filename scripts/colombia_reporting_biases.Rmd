---
title: "Colombia - reporting biases in death data"
author: "Oliver Ratmann"
#output: pdf_document 
output: 
  bookdown::html_document2:
    toc: TRUE
    toc_float: TRUE
    highlight: tango
  bookdown::pdf_book:
    keep_tex: yes
---

<style type="text/css">
h1{
  font-size: 24pt;
}
h2{
  font-size: 18pt;
}
body{
  font-size: 12pt;
}
</style>

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  cache.lazy = FALSE,
  comment = "#>"
)
```

# Packages

```{r, include=TRUE, eval=TRUE, message=FALSE, echo=TRUE, warning=FALSE, tidy=TRUE}
require(data.table) # data mangling
require(ggplot2) #for general plotting
require(ggsci) #for color palettes used by scientific journals
require(rcartocolor)
require(sf)
require(spatstat)
require(raster)
require(spdep)
require(patchwork)
require(knitr)
require(kableExtra)
require(tidyverse)

home.dir <- '/Users/or105/Library/CloudStorage/OneDrive-ImperialCollegeLondon/OR_Work/OCAY_Program'
home.dir <- '/Users/avramaral/Library/CloudStorage/OneDrive-SharedLibraries-ImperialCollegeLondon/Ratmann, Oliver - OCAY_Program/'
data.dir <- file.path(home.dir, 'Colombia_primary_data')
out.dir <- file.path(home.dir, 'Colombia_analysis_reporting_bias_in_deaths')
stamp <- gsub('-','',Sys.Date())
```

# Read data
```{r, include=TRUE, eval=TRUE, message=FALSE, echo=TRUE, warning=FALSE, tidy=TRUE}
dgeo <- as.data.table(read.csv(file.path(data.dir,'Files_Colombia/geo_info.csv')))
dmap <- readRDS(file.path(data.dir,'Files_Colombia','colombia_map_municipality.RDS'))
names(dmap)[1] <- 'mun' 

# add capitals to Departments
dgeo[, capital := mun == dep*1e3 + 1] # Check "Cundinamarca" (capital is also "BogotÃ¡")
# subset(dgeo, capital)
# TODO 25001 Cundinamarca  Agua De Dios is this correct?

# GBP data from https://www.dane.gov.co/index.php/en/statistics-by-topic-1/national-accounts/departmental-national-accounts
dgbp <- read.csv(file.path(data.dir,'Files_Colombia/anexo-2019-preliminar-PIB-total-por-departamento.csv'),
                 skip = 8, 
                 nrow = 34,
                 header = TRUE)
dgbp <- as.data.table(dgbp)
setnames(dgbp, 1:2, c('dep','dep_name'))
set(dgbp, NULL, c('X','dep_name'), NULL)
dgbp <- melt(dgbp, id.vars = c('dep'), value.name = 'gdp_per_capita', variable.name = 'year')
dgbp <- subset(dgbp, !is.na(dep))
set(dgbp, NULL, 'gdp_per_capita', dgbp[, as.integer(gsub(',','',gdp_per_capita))])
set(dgbp, NULL, 'year', dgbp[, as.integer(gsub('X|pr|p','',year))])

saveRDS(dplyr::as_tibble(dplyr::arrange(dgbp, dep)), paste(data.dir, "/summarised_data/gbp.RDS", sep = ""))

dpop <- as.data.table(readRDS(file.path(data.dir,'Population_DANE','pop_all.RDS')))
dpop_cut_age <- as.data.table(readRDS(file.path(data.dir,'Population_DANE','pop_gender.RDS')))
set(dpop, NULL, 'mun', dpop[, as.integer(as.character(mun))])
set(dpop_cut_age, NULL, 'mun', dpop_cut_age[, as.integer(as.character(mun))])
setnames(dpop, 'population','pop_DANE')
setnames(dpop_cut_age, 'population','pop_DANE')

tmp <- readRDS(file.path(data.dir,'Files_Colombia','EQUALIZED_RATES.RDS'))
dm <- as.data.table(tmp$mortality_rates)
db <- as.data.table(tmp$fertility_rates)

setnames(dm, 'loc','mun')
setnames(db, 'loc','mun')
set(dm, NULL, 'mun', dm[, as.integer(as.character(mun))])
set(db, NULL, 'mun', db[, as.integer(as.character(mun))])
set(dm, NULL, 'death_rate', NULL)
set(db, NULL, 'fertility_rate', NULL)
setnames(dm, 'population','pop_PREPR')
setnames(db, 'population','pop_PREPR')

# make sure we have all counts on the cartesian product of variables
tmp <- expand.grid(mun = dpop_cut_age[gender == 'Male', unique(mun)],
                   gender = 'Male', 
                   age = dpop_cut_age[gender == 'Male', unique(age)],
                   year = dpop_cut_age[gender == 'Male', unique(year)]
                   )
tmp <- as.data.table(tmp)
tmp2 <- expand.grid(mun = dpop_cut_age[gender == 'Female', unique(mun)],
                    gender = 'Female', 
                    age = dpop_cut_age[gender == 'Female', unique(age)],
                    year = dpop_cut_age[gender == 'Female', unique(year)]
                    )
tmp2 <- as.data.table(tmp2)
tmp <- rbind(tmp, tmp2)

dpop_cut_age <- merge(tmp, dpop_cut_age, by = c('mun','gender','age','year'), all.x = TRUE)
cat('\ndpop_cut_age: number of missing pop sizes, n=',nrow(subset(dpop_cut_age, is.na(pop_DANE))))

dpop <- merge(tmp, dpop, by = c('mun','gender','age','year'), all.x = TRUE)
cat('\ndpop: number of missing pop sizes, n=',nrow(subset(dpop, is.na(pop_DANE))))
# TODO Andre I figure out what s going on in "dpop_cut_age" -- different age strata in men/women
# qhat s the fix for dpop?


# hack for now: # This just ignores elderly. Instead, use the object based on `pop_gender`; i.e., `dpop_cut_age`
set(dpop, dpop[, which(is.na(pop_DANE))],'pop_DANE',0) 

dm <- merge(tmp, dm, by = c('mun','gender','age','year'), all.x = TRUE)
set(dm, dm[, which(is.na(deaths))], 'deaths', 0)

db <- merge(tmp, db, by = c('mun','gender','age','year'), all.x = TRUE)
set(db, db[, which(is.na(births))], 'births', 0)

# TODO Andre presumably zero here means no recorded births/deaths. 
# can you make the cartesian earlier in your code so this goes through all preprocessing too?

```

# Area data at municipality level
```{r, include=TRUE, eval=TRUE, message=FALSE, echo=TRUE, warning=FALSE, tidy=TRUE}
# area from IGAC
# https://www.esri.com/en-us/lg/industry/government/stories/igac-case-study
# https://data.humdata.org/dataset/municipal-population-density/resource/f461a4bd-349e-4666-88b1-c6daf078f980
tmp <- as.data.table(read.csv(file.path(data.dir,'Files_Colombia','densidad-municipios-de-colombia.csv')))
tmp <- subset(tmp, !is.na(COD), select = -c(POB2010, DENSIDAD))
setnames(tmp, c('COD','NAME','AREAKM2'),c('mun','mun_name_check','area'))
set(tmp, NULL, 'area', tmp[, as.integer(gsub(',','',area))])
cat("\nmunicipalities with no data on area: ", tmp[is.na(area),mun])
dgeo <- merge(dgeo, tmp, by = 'mun', all.x = TRUE)
cat("\nmunicipalities with no data on area in dgeo: ", dgeo[is.na(area),mun])

tmp <- data.table(
  mun = dmap$mun,
  area_2 = as.double(units::set_units(st_area(dmap$geometry), km^2))
)
dgeo <- merge(dgeo, tmp, by = 'mun')

tmp <- dgeo[, which(is.na(area))]
set(dgeo, tmp, 'area', dgeo[tmp, area_2])

tmp <- subset(dgeo, abs(log(area/area_2)) > log(1.2))
cat("\nThere are municipalities where km2 calculated from the shape file differs from IGAC resources by more than 20%, n=", nrow(tmp))
write.csv(tmp, file = file.path(out.dir, paste0('comparison_of_municipality_area_IGAC_vs_shapefile_',stamp,'.csv')))

# TODO Andres can you see if there is indeed an official shape file at the DANE website as 
# Catalina advised in her email. I think there was a link in her email too.
```

# Demographics in census year 2018

Switch between population sizes:

```{r, include=TRUE, eval=TRUE, message=FALSE, echo=TRUE, warning=FALSE, tidy=TRUE}
# switch pop sizes
dm <- merge(dm, dpop_cut_age, by = c('mun','gender','age','year'))
db <- merge(db, dpop_cut_age, by = c('mun','gender','age','year'))
setnames(dm, 'pop_DANE', 'pop')
setnames(db, 'pop_DANE', 'pop')

# The population count (check counts) includes all elderly individuals, whereas the birth and death count do not
```

Population density, proportion of men, proportion of people aged <30 years:

```{r, include=TRUE, eval=TRUE, message=FALSE, echo=TRUE, warning=FALSE, tidy=TRUE}
# calculate standardized mortality rates
da <- dm[year == 2018,
         list(pop_t = sum(pop)),
         by = c('mun','year')]

# add geo info
da <- merge(da, dgeo, by = 'mun', all.x = TRUE)
if (any(da[is.na(mun_name),mun]))
{
  cat("\nfound municipalities in death data that are not in geo : ", da[is.na(mun_name),mun])
}
da <- subset(da, !is.na(mun_name))

# calculate population densities
da[, pop_r := pop_t / area_2]
da[, pop_r_disc := cut(
  pop_r, breaks = c(0, 5, 25, 50, 100, 250, 100e3), 
  labels = c('0-4','5-24','25-49','50-99','100-249','250+'), 
  right = FALSE)
  ]

# plot population density
tmp <- data.table(mun = dmap$mun)
tmp[, id := 1:nrow(tmp)]
tmp <- merge(tmp, subset(da, select = c(mun, pop_r_disc)))
setkey(tmp, id)
tmp2 <- copy(dmap)
tmp2[['value']] <- tmp$pop_r_disc
p <- ggplot() +
    geom_sf(data = tmp2, 
            aes(geometry = geometry, 
                fill = value
                ), 
            color = "black") +
    scale_fill_carto_d(name = "Population per km2", palette = "Burg", direction = 1) +
    theme_bw() +
    theme(legend.position = "right",
          text = element_text(size = 14),
          plot.title = element_text(size = 16),
          legend.title = element_text(size = 11),
          panel.grid.major = element_blank(),
          panel.grid.minor = element_blank(),
          panel.border = element_blank(),
          panel.background = element_blank(),
          axis.title = element_blank(),
          axis.text = element_blank(),
          axis.ticks = element_blank()) +
    guides(fill = guide_legend(order = 1))
ggsave(p, file = file.path(out.dir, paste0('Colombia_pop_density_2018_',stamp,'.pdf')), w = 10, h = 10)


# calculate proportion of female population in selected ages 10-59 (women), 10-69 (men)
tmp <- dm[year == 2018 & gender == 'Female',
         list(pop_female_n = sum(pop)),
         by = c('mun','year')]
da <- merge(da, tmp, by = c('mun','year'))
da[, pop_female_p := pop_female_n/pop_t]

# plot population density
tmp <- data.table(mun = dmap$mun)
tmp[, id := 1:nrow(tmp)]
tmp <- merge(tmp, subset(da, select = c(mun, pop_female_p)))
tmp[, pop_female_p_disc := cut(pop_female_p, breaks = c(0,0.4,1.0))]
setkey(tmp, id)
tmp2 <- copy(dmap)
tmp2[['value']] <- tmp$pop_female_p_disc
p <- ggplot() +
    geom_sf(data = tmp2, 
            aes(geometry = geometry, 
                fill = value
                ), 
            color = "black") +
    scale_fill_carto_d(name = "Proportion of women in population (%)", palette = "Teal", direction = -1) +
    theme_bw() +
    theme(legend.position = "right",
          text = element_text(size = 14),
          plot.title = element_text(size = 16),
          legend.title = element_text(size = 11),
          panel.grid.major = element_blank(),
          panel.grid.minor = element_blank(),
          panel.border = element_blank(),
          panel.background = element_blank(),
          axis.title = element_blank(),
          axis.text = element_blank(),
          axis.ticks = element_blank()) +
    guides(fill = guide_legend(order = 1))
ggsave(p, file = file.path(out.dir, paste0('Colombia_proportion_women_2018_',stamp,'.pdf')), w = 10, h = 10)

# TODO check municipalities with <40% women!
tmp <- subset(da, pop_female_p < 0.4 | pop_female_p > 0.6)
write.csv(tmp, file = file.path(out.dir, paste0('Colombia_proportion_women_2018_odd_',stamp,'.csv')))

# calculate proportion of population in ages 10-29 in selected age range
tmp <- dm[year == 2018 & age %in% c("10-14","15-19","20-24","25-29"),
         list(pop_10_29_n = sum(pop)),
         by = c('mun','year')]
da <- merge(da, tmp, by = c('mun','year'))
da[, pop_10_29_p := pop_female_n/pop_t]

# plot proportion of population in ages 10-29 in selected age range
tmp <- data.table(mun = dmap$mun)
tmp[, id := 1:nrow(tmp)]
tmp <- merge(tmp, subset(da, select = c(mun, pop_10_29_p)))
tmp[, pop_10_29_p_disc := cut(pop_10_29_p, breaks = c(0,0.4,1.0))]
setkey(tmp, id)
tmp2 <- copy(dmap)
tmp2[['value']] <- tmp$pop_10_29_p_disc
p <- ggplot() +
    geom_sf(data = tmp2, 
            aes(geometry = geometry, 
                fill = value
                ), 
            color = "black") +
    scale_fill_carto_d(name = "Proportion of people aged 10-29 in population (%)", palette = "Peach", direction = -1) +
    theme_bw() +
    theme(legend.position = "right",
          text = element_text(size = 14),
          plot.title = element_text(size = 16),
          legend.title = element_text(size = 11),
          panel.grid.major = element_blank(),
          panel.grid.minor = element_blank(),
          panel.border = element_blank(),
          panel.background = element_blank(),
          axis.title = element_blank(),
          axis.text = element_blank(),
          axis.ticks = element_blank()) +
    guides(fill = guide_legend(order = 1))
ggsave(p, file = file.path(out.dir, paste0('Colombia_proportion_people_10_29_2018_',stamp,'.pdf')), w = 10, h = 10)


tmp <- subset(da, pop_10_29_p < 0.4 | pop_10_29_p > 0.6)
write.csv(tmp, file = file.path(out.dir, paste0('Colombia_proportion_people_10_29_2018_odd_',stamp,'.csv')))
# TODO check municipalities with <40% young people!

```


# Standardized mortality rates in census year 2018

Standardized mortality rates in census year 2018, ignoring women aged >67 and men aged >77:

```{r, include=TRUE, eval=TRUE, message=FALSE, echo=TRUE, warning=FALSE, tidy=TRUE}
# prepare national reference population
dref <- dm[ year == 2018, 
            list(natl_pop_n = sum(pop)),
            by = c('gender','age')]
dref[, natl_pop_t := sum(natl_pop_n)]
dref[, natl_pop_p := natl_pop_n / natl_pop_t]

# calculate age/sex death rates per municipality
da <- subset(dm, year == 2018, select = -c(mod, pop_PREPR))
da[, mun_death_r_2018 := deaths/pop]
tmp <- da[, which(pop == 0.)]
set(da, tmp, 'mun_death_r_2018', 0.)

# merge national reference population weights
da <- merge(da, dref, by = c('gender','age'), all.x = TRUE)

# calculate standardized mortality rates
da <- da[,
         list(pop_n = sum(pop),
              deaths = sum(deaths),
              death_r = sum(deaths)/sum(pop),
              death_r_std = sum(mun_death_r_2018 * natl_pop_n) / natl_pop_t[1] 
              ),
         by = c('mun','year')]

# add geo info
da <- merge(da, dgeo, by = 'mun', all.x = TRUE)
cat("\nfound municipalities in death data that are not in geo : ", da[is.na(mun_name),mun])
da <- subset(da, !is.na(mun_name))

# add GBP info
da <- merge(da, dgbp, by = c('dep','year'), all.x = TRUE)


# calculate population densities
da[, pop_r := pop_n / area_2]
da[, pop_r_disc := cut(
  pop_r, breaks = c(0, 5, 25, 50, 100, 250, 100e3), 
  labels = c('0-4','5-24','25-49','50-99','100-249','250+'), 
  right = FALSE)
  ]

# plot population density
tmp <- data.table(mun = dmap$mun)
tmp[, id := 1:nrow(tmp)]
tmp <- merge(tmp, subset(da, select = c(mun, pop_r_disc)))
setkey(tmp, id)
tmp2 <- copy(dmap)
tmp2[['value']] <- tmp$pop_r_disc
p <- ggplot() +
    geom_sf(data = tmp2, 
            aes(geometry = geometry, 
                fill = value
                ), 
            color = "black") +
    scale_fill_carto_d(name = "Population per km2", palette = "Burg", direction = 1) +
    theme_bw() +
    theme(legend.position = "right",
          text = element_text(size = 14),
          plot.title = element_text(size = 16),
          legend.title = element_text(size = 11),
          panel.grid.major = element_blank(),
          panel.grid.minor = element_blank(),
          panel.border = element_blank(),
          panel.background = element_blank(),
          axis.title = element_blank(),
          axis.text = element_blank(),
          axis.ticks = element_blank()) +
    guides(fill = guide_legend(order = 1))
ggsave(p, file = file.path(out.dir, paste0('Colombia_pop_density_2018_',stamp,'.pdf')), w = 10, h = 10)

# plot population density
#ggplot(da, aes(x= death_r, y= death_r_std)) + geom_point()\
#

# plot standardised death rates
da[, death_r_std_disc := cut(
  death_r_std, breaks = c(-1, 1e-7, 1e-3, 2e-3, 3e-3, 4e-3, 1), 
  labels = c('0','<=1 per 1000','<=2 per 1000','<=3 per 1000','<=4 per 1000','>4 per 1000'), 
  right = TRUE)
  ]

tmp <- data.table(mun = dmap$mun)
tmp[, id := 1:nrow(tmp)]
tmp <- merge(tmp, subset(da, select = c(mun, death_r_std_disc)))
setkey(tmp, id)
tmp2 <- copy(dmap)
tmp2[['value']] <- tmp$death_r_std_disc
p <- ggplot() +
    geom_sf(data = tmp2, 
            aes(geometry = geometry, 
                fill = value
                ), 
            color = "black") +
    scale_fill_carto_d(name = "Standardized mortality rate in 2018", palette = "Burg", direction = 1) +
    theme_bw() +
    theme(legend.position = "right",
          text = element_text(size = 14),
          plot.title = element_text(size = 16),
          legend.title = element_text(size = 11),
          panel.grid.major = element_blank(),
          panel.grid.minor = element_blank(),
          panel.border = element_blank(),
          panel.background = element_blank(),
          axis.title = element_blank(),
          axis.text = element_blank(),
          axis.ticks = element_blank()) +
    guides(fill = guide_legend(order = 1))
ggsave(p, file = file.path(out.dir, paste0('Colombia_mortality_rate_2018_',stamp,'.pdf')), w = 10, h = 10)

# are standardized death rates higher in capitals of departments?

tmp <- unique(subset(da, select = c(dep_name, gdp_per_capita)))
setkey(tmp, gdp_per_capita)
tmp[, dep_name_gdp := factor(1:nrow(tmp), levels = 1:nrow(tmp), labels = dep_name) ]
da <- merge(da, tmp, by = c('dep_name', 'gdp_per_capita'))
p <- ggplot(da, aes(x = dep_name_gdp, y = death_r_std)) +
  geom_boxplot() +
  geom_point(data = subset(da, capital == TRUE), col = 'red') +
  coord_flip() + 
  theme_bw() +
  ylab('standardized\nmortality rate') + 
  xlab('Departments ordered by GBP')
ggsave(p, file = file.path(out.dir, paste0('Colombia_mortality_rate_2018_capital_vs_mun_ordered_by_gdp',stamp,'.png')), w = 10, h = 10)

# GDP by Department
p <- ggplot(data = unique(subset(da, select = c(dep_name_gdp, gdp_per_capita)))) +
  geom_col(aes(x = dep_name_gdp, y = gdp_per_capita)) +
  theme_bw() +
  coord_flip() +
  labs(y = "GDP per capita\n(million pesos)", x = 'Department')
ggsave(p, file = file.path(out.dir, paste0('Colombia_Departments_by_gdp',stamp,'.png')), w = 10, h = 10)

# can we try and work out some correction factor?

dg <- subset(da, select = c(dep, dep_name_gdp, gdp_per_capita, mun, capital, death_r_std))
tmp <- subset(dg, capital, select = c(dep, death_r_std))
setnames(tmp, 'death_r_std', 'death_r_std_capital')
dg <- merge(dg, tmp, by = 'dep')
dg <- dg[, 
         list(death_r_std_capital_quantile = mean(as.integer(death_r_std <= death_r_std_capital))), 
         by = c('dep','dep_name_gdp','gdp_per_capita')
         ]
setorder(dg, -gdp_per_capita)
dg <- subset(dg, dep != 11)
dg[, death_r_std_capital_quantile_run := sapply( 1:nrow(dg), function(i){ mean(dg$death_r_std_capital_quantile[1:i]) })]

p <- ggplot(dg) +
  geom_line(aes( x = dep_name_gdp, y = death_r_std_capital_quantile_run, group = 1)) +
  geom_point(aes( x = dep_name_gdp, y = death_r_std_capital_quantile)) +
  scale_y_continuous( labels = scales::percent ) +
  theme_bw() + 
  coord_flip() +
  labs(y = "proportion of standardized death rates\nbelow that in the capital", x = 'Departments (excl Bogota)\nordered by GDP')
ggsave(p, file = file.path(out.dir, paste0('Colombia_Mortality_rate_2018_prop_below_capital_by_gdp',stamp,'.png')), w = 10, h = 10)

# quantile for Putumayo is 66%
subset(dg, dep_name_gdp == 'Putumayo')

# adjust standardised death rates 

```

